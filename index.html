<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Non-Deterministic Drum Synth</title>
<style>
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  background: #111;
  color: #eee;
  font-family: 'SF Mono', monospace;
  min-height: 100vh;
  user-select: none;
}

.app {
  display: flex;
  min-height: 100vh;
}

.main {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 48px 16px;
  transition: margin-right 0.25s;
}

.app.editor-open .main {
  margin-right: 320px;
}

h1 {
  font-size: 14px;
  font-weight: 400;
  letter-spacing: 4px;
  text-transform: uppercase;
  color: #555;
  margin-bottom: 32px;
}

button {
  background: none;
  border: 1px solid #333;
  color: #eee;
  font-family: inherit;
  font-size: 13px;
  padding: 6px 16px;
  cursor: pointer;
  border-radius: 3px;
  transition: border-color 0.15s;
}

button:hover {
  border-color: #666;
}

button.active {
  border-color: #fff;
  color: #fff;
}

input[type="range"] {
  width: 80px;
  accent-color: #888;
}

.transport {
  display: flex;
  align-items: center;
  gap: 16px;
  margin-bottom: 20px;
}

.transport label {
  font-size: 12px;
  color: #666;
  display: flex;
  align-items: center;
  gap: 6px;
}

.transport .val {
  color: #aaa;
  font-size: 12px;
  min-width: 32px;
}

.presets {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 20px;
  flex-wrap: wrap;
  justify-content: center;
}

.presets select {
  background: #1a1a1a;
  color: #aaa;
  border: 1px solid #333;
  border-radius: 3px;
  padding: 5px 8px;
  font-family: inherit;
  font-size: 12px;
  min-width: 140px;
}

.presets button {
  font-size: 11px;
  padding: 5px 12px;
}

.presets .label {
  font-size: 11px;
  color: #444;
  text-transform: uppercase;
  letter-spacing: 1px;
}

.save-dot {
  width: 6px;
  height: 6px;
  border-radius: 50%;
  background: #333;
  display: inline-block;
  transition: background 0.3s;
}

.save-dot.cached {
  background: #5bc0be;
}

.save-dot.dirty {
  background: #f4d35e;
}

.grid {
  display: grid;
  grid-template-columns: 160px repeat(16, 36px);
  gap: 3px;
}

.row-label {
  display: flex;
  align-items: center;
  justify-content: flex-end;
  padding-right: 8px;
  gap: 4px;
  font-size: 11px;
  color: #555;
  letter-spacing: 1px;
  text-transform: uppercase;
  height: 36px;
  overflow: hidden;
  white-space: nowrap;
}

.row-label .name {
  overflow: hidden;
  text-overflow: ellipsis;
  cursor: pointer;
  transition: color 0.15s;
}

.row-label .name:hover {
  color: #999;
}

.row-label.editing .name {
  color: #fff;
}

.row-label .key {
  color: #333;
  font-size: 10px;
  flex-shrink: 0;
}

.row-prob {
  display: flex;
  align-items: center;
  gap: 2px;
  flex-shrink: 0;
}

.row-prob input[type="range"] {
  width: 36px;
  height: 3px;
  accent-color: var(--color);
}

.row-prob span {
  font-size: 8px;
  color: #444;
  width: 22px;
  text-align: right;
}

.cell {
  width: 36px;
  height: 36px;
  background: #1a1a1a;
  border-radius: 3px;
  cursor: pointer;
  transition: background 0.1s;
  position: relative;
}

.cell:hover {
  background: #252525;
}

.cell.odd-group {
  background: #1e1e1e;
}

.cell.odd-group:hover {
  background: #282828;
}

.cell.on {
  background: var(--color);
  opacity: var(--prob, 1);
}

.cell.on:hover {
  filter: brightness(1.2);
}

.cell .prob-label {
  position: absolute;
  bottom: 1px;
  right: 2px;
  font-size: 7px;
  color: rgba(0,0,0,0.5);
  pointer-events: none;
  line-height: 1;
}

.playhead {
  position: absolute;
  inset: 0;
  border: 1px solid rgba(255,255,255,0.6);
  border-radius: 3px;
  pointer-events: none;
}

.pads {
  display: flex;
  gap: 8px;
  margin-top: 28px;
  flex-wrap: wrap;
  justify-content: center;
}

.pad {
  width: 72px;
  height: 72px;
  background: #1a1a1a;
  border: 1px solid #252525;
  border-radius: 5px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all 0.08s;
  gap: 4px;
}

.pad:active,
.pad.hit {
  transform: scale(0.95);
  border-color: var(--color);
  background: #222;
}

.pad .pad-key {
  font-size: 16px;
  color: var(--color);
  font-weight: 600;
}

.pad .pad-name {
  font-size: 10px;
  color: #666;
  text-transform: uppercase;
  letter-spacing: 1px;
}

.add-sound {
  margin-top: 12px;
  display: flex;
  justify-content: center;
}

.add-sound button {
  font-size: 11px;
  padding: 4px 14px;
  color: #555;
  border-color: #333;
  border-style: dashed;
}

.combos {
  margin-top: 28px;
  font-size: 12px;
  color: #555;
  letter-spacing: 1px;
  text-align: center;
}

.combos strong {
  color: #888;
  font-weight: 600;
}

.hint {
  margin-top: 10px;
  font-size: 11px;
  color: #333;
  letter-spacing: 1px;
}

.editor {
  position: fixed;
  top: 0;
  right: 0;
  width: 320px;
  height: 100vh;
  background: #161616;
  border-left: 1px solid #222;
  padding: 24px 20px;
  overflow-y: auto;
  transform: translateX(100%);
  transition: transform 0.25s;
}

.editor.open {
  transform: translateX(0);
}

.editor-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 16px;
  flex-wrap: wrap;
  gap: 8px;
}

.editor-title {
  font-size: 13px;
  text-transform: uppercase;
  letter-spacing: 2px;
  background: none;
  border: none;
  border-bottom: 1px solid #333;
  font-family: inherit;
  padding: 2px 0;
  width: 100px;
  outline: none;
  color: #888;
}

.editor-title:focus {
  border-bottom-color: #666;
}

.editor-actions {
  display: flex;
  gap: 6px;
  flex-wrap: wrap;
}

.editor-actions button {
  font-size: 10px;
  padding: 3px 8px;
}

.layer {
  background: #1a1a1a;
  border: 1px solid #222;
  border-radius: 4px;
  padding: 14px;
  margin-bottom: 10px;
}

.layer-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 12px;
}

.layer-type {
  font-size: 11px;
  color: #666;
  text-transform: uppercase;
  letter-spacing: 1px;
}

.layer-remove {
  font-size: 11px;
  padding: 2px 8px;
  color: #666;
  border-color: #222;
}

.param {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 6px;
}

.param .param-name {
  font-size: 11px;
  color: #555;
  width: 80px;
  text-align: right;
  flex-shrink: 0;
}

.param input[type="range"] {
  flex: 1;
  width: auto;
}

.param .param-val {
  font-size: 11px;
  color: #777;
  width: 48px;
  text-align: left;
}

.param select {
  background: #222;
  color: #aaa;
  border: 1px solid #333;
  border-radius: 3px;
  padding: 2px 6px;
  font-family: inherit;
  font-size: 11px;
}

.add-layer {
  display: flex;
  gap: 8px;
  margin-top: 8px;
}

.add-layer button {
  font-size: 11px;
  padding: 4px 12px;
  color: #666;
  border-color: #333;
  border-style: dashed;
}
</style>
</head>
<body>
<div class="app" id="app">
<div class="main">
  <h1>Non-Deterministic Synth</h1>

  <div class="transport">
    <button id="playBtn">Play</button>
    <button id="clearBtn">Clear</button>
    <label>BPM <input type="range" id="bpmSlider" min="60" max="200" value="120"><span class="val" id="bpmVal">120</span></label>
    <label>Swing <input type="range" id="swingSlider" min="0" max="80" value="0"><span class="val" id="swingVal">0%</span></label>
  </div>

  <div class="presets">
    <span class="label">Presets</span>
    <select id="presetSelect"><option value="">-- unsaved --</option></select>
    <button id="saveBtn">Save</button>
    <button id="saveAsBtn">Save As</button>
    <button id="deletePresetBtn">Delete</button>
    <span class="save-dot" id="saveDot" title="cached"></span>
  </div>

  <div class="grid" id="grid"></div>
  <div class="pads" id="pads"></div>
  <div class="add-sound"><button id="addDrumBtn">+ Add Sound</button></div>
  <p class="combos" id="combos"></p>
  <p class="hint">click name to edit · right-click cell for per-step probability · space to play/stop</p>
</div>
<div class="editor" id="editor"></div>
</div>

<script>
const $ = id => document.getElementById(id);

// Audio — resume context eagerly on first user gesture to eliminate latency
const ctx = new (window.AudioContext || window.webkitAudioContext)();
const master = ctx.createDynamicsCompressor();
master.threshold.value = -6;
master.ratio.value = 4;
master.connect(ctx.destination);

function warmUpAudio() {
  if (ctx.state === 'suspended') ctx.resume();
  document.removeEventListener('mousedown', warmUpAudio);
  document.removeEventListener('keydown', warmUpAudio);
}
document.addEventListener('mousedown', warmUpAudio);
document.addEventListener('keydown', warmUpAudio);

// Pre-generate reusable noise buffer
const noiseBuffer = ctx.createBuffer(1, ctx.sampleRate * 2, ctx.sampleRate);
const noiseData = noiseBuffer.getChannelData(0);
for (let i = 0; i < noiseData.length; i++) noiseData[i] = Math.random() * 2 - 1;

// Sound definitions — each drum is layers of oscillators and/or filtered noise
const drums = [
  { name: 'Kick', key: 'q', color: '#e85d75', prob: 100,
    layers: [{ type: 'osc', wave: 'sine', freq: 160, freqEnd: 40, freqDecay: 0.12, decay: 0.4, gain: 1 }] },
  { name: 'Snare', key: 'w', color: '#5bc0be', prob: 100,
    layers: [
      { type: 'noise', filter: 'highpass', filterFreq: 1000, filterQ: 1, decay: 0.15, gain: 0.7 },
      { type: 'osc', wave: 'triangle', freq: 200, freqEnd: 100, freqDecay: 0.05, decay: 0.1, gain: 0.5 }
    ] },
  { name: 'Hat', key: 'e', color: '#f4d35e', prob: 100,
    layers: [{ type: 'noise', filter: 'bandpass', filterFreq: 10000, filterQ: 1, decay: 0.06, gain: 0.3 }] },
  { name: 'Clap', key: 'r', color: '#9b5de5', prob: 100,
    layers: [{ type: 'noise', filter: 'bandpass', filterFreq: 2500, filterQ: 0.5, decay: 0.08, gain: 0.4, count: 3 }] }
];

// Synth engine
function playDrum(drum, time) {
  for (const layer of drum.layers) {
    layer.type === 'osc' ? playOsc(layer, time) : playNoise(layer, time);
  }
}

function playOsc(l, time) {
  const osc = ctx.createOscillator();
  const gain = ctx.createGain();
  osc.type = l.wave || 'sine';
  osc.frequency.setValueAtTime(l.freq, time);
  if (l.freqEnd && l.freqDecay)
    osc.frequency.exponentialRampToValueAtTime(Math.max(l.freqEnd, 1), time + l.freqDecay);
  gain.gain.setValueAtTime(l.gain, time);
  gain.gain.exponentialRampToValueAtTime(0.001, time + l.decay);
  osc.connect(gain);
  gain.connect(master);
  osc.start(time);
  osc.stop(time + l.decay);
}

function playNoise(l, time) {
  for (let b = 0; b < (l.count || 1); b++) {
    const offset = b * 0.01;
    const src = ctx.createBufferSource();
    const gain = ctx.createGain();
    const filter = ctx.createBiquadFilter();
    src.buffer = noiseBuffer;
    gain.gain.setValueAtTime(l.gain, time + offset);
    gain.gain.exponentialRampToValueAtTime(0.001, time + offset + l.decay);
    filter.type = l.filter || 'highpass';
    filter.frequency.value = l.filterFreq || 1000;
    filter.Q.value = l.filterQ || 1;
    src.connect(filter);
    filter.connect(gain);
    gain.connect(master);
    src.start(time + offset, 0, l.decay);
    src.stop(time + offset + l.decay);
  }
}

// Constants
const STEPS = 16;
const KEY_POOL = 'qwertyuiopasdfghjklzxcvbnm1234567890'.split('');
const COLORS = ['#e85d75', '#5bc0be', '#f4d35e', '#9b5de5', '#f77f00', '#06d6a0', '#118ab2', '#ef476f', '#ffd166', '#83c5be'];
const STORAGE_KEY = 'drumsynth';

// State — pattern values: 0=off, -1=on(row prob), 1-99=per-cell override
let pattern = drums.map(() => Array(STEPS).fill(0));
let playing = false, currentStep = -1, bpm = 120, swing = 0;
let timerId = null, nextStepTime = 0;
let cellEls = [], playheadEls = [], editingDrum = -1;

// DOM refs
const appEl = $('app'), gridEl = $('grid'), padsEl = $('pads'), editorEl = $('editor');
const playBtn = $('playBtn'), combosEl = $('combos');
const bpmSlider = $('bpmSlider'), bpmVal = $('bpmVal');
const swingSlider = $('swingSlider'), swingVal = $('swingVal');
const presetSelect = $('presetSelect'), saveDot = $('saveDot');

// Probability helpers
function effectiveProb(row, step) {
  const v = pattern[row][step];
  if (v === 0) return 0;
  if (v === -1) return drums[row].prob || 100;
  return v;
}

function updateCellVisual(cell, row, step) {
  const v = pattern[row][step];
  const eff = effectiveProb(row, step);
  if (v !== 0) {
    cell.classList.add('on');
    cell.style.setProperty('--prob', 0.3 + (eff / 100) * 0.7);
    let label = cell.querySelector('.prob-label');
    if (v > 0 && v < 100) {
      if (!label) {
        label = document.createElement('span');
        label.className = 'prob-label';
        cell.appendChild(label);
      }
      label.textContent = v + '%';
    } else if (label) {
      label.remove();
    }
  } else {
    cell.classList.remove('on');
    cell.style.removeProperty('--prob');
    const label = cell.querySelector('.prob-label');
    if (label) label.remove();
  }
}

function updateCombos() {
  let probabilistic = 0, totalActive = 0;
  for (let r = 0; r < drums.length; r++) {
    for (let s = 0; s < STEPS; s++) {
      const eff = effectiveProb(r, s);
      if (eff > 0) {
        totalActive++;
        if (eff < 100) probabilistic++;
      }
    }
  }
  if (probabilistic === 0) {
    combosEl.innerHTML = totalActive > 0 ? '<strong>1</strong> possible pattern (fully deterministic)' : '';
  } else {
    combosEl.innerHTML = `<strong>${Math.pow(2, probabilistic).toLocaleString()}</strong> possible patterns from <strong>${probabilistic}</strong> probabilistic cells`;
  }
}

// Key management
function nextAvailableKey() {
  const used = new Set(drums.map(d => d.key));
  return KEY_POOL.find(k => !used.has(k)) || null;
}

// Build UI
function rebuildUI() {
  gridEl.innerHTML = '';
  padsEl.innerHTML = '';
  cellEls = [];

  // Build key map
  const keyMap = {};
  drums.forEach((drum, i) => {
    if (drum.key === '?') drum.key = nextAvailableKey();
    if (drum.key) keyMap[drum.key] = i;
  });
  window._keyMap = keyMap;

  drums.forEach((drum, row) => {
    if (!drum.prob && drum.prob !== 0) drum.prob = 100;

    // Row label with name, key hint, probability slider
    const label = document.createElement('div');
    label.className = 'row-label' + (editingDrum === row ? ' editing' : '');
    const keyHint = drum.key ? `<span class="key">${drum.key.toUpperCase()}</span>` : '';
    label.innerHTML = `
      <span class="name" onclick="openEditor(${row})">${drum.name}</span>${keyHint}
      <span class="row-prob">
        <input type="range" min="0" max="100" step="5" value="${drum.prob}"
          style="--color:${drum.color}"
          oninput="setRowProb(${row}, +this.value); this.nextElementSibling.textContent = this.value + '%'">
        <span>${drum.prob}%</span>
      </span>`;
    gridEl.appendChild(label);

    // Step cells
    cellEls[row] = [];
    for (let step = 0; step < STEPS; step++) {
      const cell = document.createElement('div');
      cell.className = 'cell' + (Math.floor(step / 4) % 2 ? ' odd-group' : '');
      cell.style.setProperty('--color', drum.color);

      // Migrate old formats
      if (pattern[row]) {
        if (pattern[row][step] === true) pattern[row][step] = -1;
        if (pattern[row][step] === false) pattern[row][step] = 0;
        if (pattern[row][step] === 100) pattern[row][step] = -1;
      }

      updateCellVisual(cell, row, step);

      // Left click: toggle on/off
      cell.addEventListener('mousedown', e => {
        if (e.button !== 0) return;
        pattern[row][step] = pattern[row][step] !== 0 ? 0 : -1;
        updateCellVisual(cell, row, step);
      });

      // Right click: cycle per-cell override (25 → 50 → 75 → row default)
      cell.addEventListener('contextmenu', e => {
        e.preventDefault();
        if (!pattern[row][step]) return;
        const overrides = [-1, 25, 50, 75];
        const idx = overrides.indexOf(pattern[row][step]);
        pattern[row][step] = overrides[(idx + 1) % 4];
        updateCellVisual(cell, row, step);
      });

      gridEl.appendChild(cell);
      cellEls[row][step] = cell;
    }
  });

  // Trigger pads
  drums.forEach((drum, row) => {
    const pad = document.createElement('div');
    pad.className = 'pad';
    pad.style.setProperty('--color', drum.color);
    pad.innerHTML = `<span class="pad-key">${drum.key ? drum.key.toUpperCase() : ''}</span><span class="pad-name">${drum.name}</span>`;
    pad.addEventListener('mousedown', () => triggerPad(row));
    padsEl.appendChild(pad);
  });
}

function setRowProb(row, val) {
  drums[row].prob = val;
  if (cellEls[row]) {
    for (let s = 0; s < STEPS; s++) {
      if (pattern[row][s] !== 0) updateCellVisual(cellEls[row][s], row, s);
    }
  }
}

function triggerPad(row) {
  if (ctx.state === 'suspended') ctx.resume();
  playDrum(drums[row], ctx.currentTime);
  const pad = padsEl.children[row];
  if (pad) {
    pad.classList.add('hit');
    setTimeout(() => pad.classList.remove('hit'), 100);
  }
}

// Editor
function openEditor(row) {
  if (editingDrum === row) {
    editingDrum = -1;
    editorEl.classList.remove('open');
    appEl.classList.remove('editor-open');
    rebuildUI();
    return;
  }
  editingDrum = row;
  editorEl.classList.add('open');
  appEl.classList.add('editor-open');
  rebuildUI();
  renderEditor();
}

function renderEditor() {
  const drum = drums[editingDrum];
  if (!drum) return;

  let html = `<div class="editor-header">
    <input class="editor-title" style="color:${drum.color}" value="${drum.name}"
      oninput="renameDrum(this.value)" spellcheck="false">
    <div class="editor-actions">
      ${drums.length > 1 ? `<button onclick="removeDrum(${editingDrum})">Delete</button>` : ''}
    </div>
  </div>`;

  drum.layers.forEach((layer, li) => {
    const isOsc = layer.type === 'osc';
    html += `<div class="layer">
      <div class="layer-header">
        <span class="layer-type">${isOsc ? 'Oscillator' : 'Noise'}</span>
        <button class="layer-remove" onclick="removeLayer(${li})">Remove</button>
      </div>`;

    if (isOsc) {
      html += selectParam(li, 'wave', layer.wave, ['sine', 'triangle', 'square', 'sawtooth'])
        + sliderParam(li, 'freq', 'Frequency', layer.freq, 20, 2000, 1, 'Hz')
        + sliderParam(li, 'freqEnd', 'Freq End', layer.freqEnd, 10, 2000, 1, 'Hz')
        + sliderParam(li, 'freqDecay', 'Pitch Decay', layer.freqDecay, 0.01, 1, 0.01, 's')
        + sliderParam(li, 'decay', 'Decay', layer.decay, 0.01, 2, 0.01, 's')
        + sliderParam(li, 'gain', 'Gain', layer.gain, 0, 1, 0.01, '');
    } else {
      html += selectParam(li, 'filter', layer.filter, ['highpass', 'lowpass', 'bandpass'])
        + sliderParam(li, 'filterFreq', 'Filter Freq', layer.filterFreq, 100, 15000, 10, 'Hz')
        + sliderParam(li, 'filterQ', 'Filter Q', layer.filterQ, 0.1, 10, 0.1, '')
        + sliderParam(li, 'decay', 'Decay', layer.decay, 0.01, 1, 0.01, 's')
        + sliderParam(li, 'gain', 'Gain', layer.gain, 0, 1, 0.01, '')
        + sliderParam(li, 'count', 'Bursts', layer.count || 1, 1, 8, 1, '');
    }
    html += '</div>';
  });

  html += `<div class="add-layer">
    <button onclick="addLayer('osc')">+ Oscillator</button>
    <button onclick="addLayer('noise')">+ Noise</button>
  </div>`;

  editorEl.innerHTML = html;
}

function sliderParam(li, key, label, value, min, max, step, unit) {
  return `<div class="param">
    <span class="param-name">${label}</span>
    <input type="range" min="${min}" max="${max}" step="${step}" value="${value}"
      oninput="setParam(${li},'${key}',+this.value); this.nextElementSibling.textContent=this.value+'${unit}'">
    <span class="param-val">${value}${unit}</span>
  </div>`;
}

function selectParam(li, key, value, options) {
  const opts = options.map(o => `<option${o === value ? ' selected' : ''}>${o}</option>`).join('');
  return `<div class="param">
    <span class="param-name">${key}</span>
    <select onchange="setParam(${li},'${key}',this.value)">${opts}</select>
  </div>`;
}

function setParam(li, key, value) {
  drums[editingDrum].layers[li][key] = value;
}

function renameDrum(name) {
  drums[editingDrum].name = name;
  rebuildUI();
}

function addLayer(type) {
  const defaults = type === 'osc'
    ? { type: 'osc', wave: 'sine', freq: 200, freqEnd: 80, freqDecay: 0.1, decay: 0.2, gain: 0.5 }
    : { type: 'noise', filter: 'highpass', filterFreq: 2000, filterQ: 1, decay: 0.1, gain: 0.4, count: 1 };
  drums[editingDrum].layers.push(defaults);
  renderEditor();
}

function removeLayer(li) {
  drums[editingDrum].layers.splice(li, 1);
  renderEditor();
}

function removeDrum(row) {
  drums.splice(row, 1);
  pattern.splice(row, 1);
  editingDrum = -1;
  editorEl.classList.remove('open');
  appEl.classList.remove('editor-open');
  rebuildUI();
}

function addDrum() {
  drums.push({
    name: 'New', key: nextAvailableKey(), color: COLORS[drums.length % COLORS.length], prob: 100,
    layers: [{ type: 'osc', wave: 'sine', freq: 200, freqEnd: 80, freqDecay: 0.1, decay: 0.2, gain: 0.5 }]
  });
  pattern.push(Array(STEPS).fill(0));
  rebuildUI();
  openEditor(drums.length - 1);
}

// Sequencer
function stepInterval() { return 60 / bpm / 4; }

function scheduler() {
  while (nextStepTime < ctx.currentTime + 0.05) {
    currentStep = (currentStep + 1) % STEPS;
    const swingOffset = currentStep % 2 === 1 ? stepInterval() * (swing / 100) * 0.7 : 0;
    const time = nextStepTime + swingOffset;

    drums.forEach((drum, row) => {
      const eff = effectiveProb(row, currentStep);
      if (eff > 0 && Math.random() * 100 < eff) playDrum(drum, time);
    });

    // Update playhead
    for (let i = 0; i < playheadEls.length; i++) playheadEls[i].remove();
    playheadEls = [];
    for (let row = 0; row < drums.length; row++) {
      if (cellEls[row] && cellEls[row][currentStep]) {
        const ph = document.createElement('div');
        ph.className = 'playhead';
        cellEls[row][currentStep].appendChild(ph);
        playheadEls.push(ph);
      }
    }

    nextStepTime += stepInterval();
  }
  timerId = setTimeout(scheduler, 20);
}

function togglePlay() {
  if (playing) {
    playing = false;
    clearTimeout(timerId);
    playBtn.textContent = 'Play';
    playBtn.classList.remove('active');
    for (let i = 0; i < playheadEls.length; i++) playheadEls[i].remove();
    playheadEls = [];
    currentStep = -1;
  } else {
    if (ctx.state === 'suspended') ctx.resume();
    playing = true;
    currentStep = -1;
    nextStepTime = ctx.currentTime;
    playBtn.textContent = 'Stop';
    playBtn.classList.add('active');
    scheduler();
  }
}

// Controls
playBtn.addEventListener('click', togglePlay);

$('clearBtn').addEventListener('click', () => {
  pattern.forEach(row => row.fill(0));
  cellEls.forEach((row, ri) => row.forEach((cell, si) => updateCellVisual(cell, ri, si)));
});

bpmSlider.addEventListener('input', () => {
  bpm = +bpmSlider.value;
  bpmVal.textContent = bpm;
});

swingSlider.addEventListener('input', () => {
  swing = +swingSlider.value;
  swingVal.textContent = swing + '%';
});

$('addDrumBtn').addEventListener('click', addDrum);

document.addEventListener('keydown', e => {
  if (e.repeat || e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;
  if (e.key === ' ') { e.preventDefault(); togglePlay(); return; }
  const km = window._keyMap;
  if (km && e.key.toLowerCase() in km) { e.preventDefault(); triggerPad(km[e.key.toLowerCase()]); }
});

// Storage
let currentPreset = '';  // name of loaded preset, '' = unsaved
let dirty = false;

function getState() {
  return { drums: drums.map(d => ({ name: d.name, key: d.key, color: d.color, prob: d.prob, layers: d.layers })), pattern, bpm, swing };
}

function loadState(state) {
  drums.length = 0;
  state.drums.forEach(d => drums.push(d));
  pattern = state.pattern || drums.map(() => Array(STEPS).fill(0));
  if (state.bpm) { bpm = state.bpm; bpmSlider.value = bpm; bpmVal.textContent = bpm; }
  if (state.swing != null) { swing = state.swing; swingSlider.value = swing; swingVal.textContent = swing + '%'; }
  editingDrum = -1;
  editorEl.classList.remove('open');
  appEl.classList.remove('editor-open');
  rebuildUI();
}

function markDirty() {
  dirty = true;
  saveDot.classList.add('dirty');
}

// Cache to session storage so work isn't lost on refresh (not the same as saving a preset)
let cacheTimer = null;
function cacheSession() {
  clearTimeout(cacheTimer);
  cacheTimer = setTimeout(() => {
    localStorage.setItem(STORAGE_KEY + ':session', JSON.stringify({ ...getState(), _preset: currentPreset }));
    saveDot.classList.add('cached');
    setTimeout(() => saveDot.classList.remove('cached'), 600);
  }, 300);
}

function onChange() {
  markDirty();
  cacheSession();
}

// Hook onChange into mutations
const _setParam = setParam;
setParam = function(li, key, value) { _setParam(li, key, value); onChange(); };
const _rebuildUI = rebuildUI;
rebuildUI = function() { _rebuildUI(); updateCombos(); onChange(); };

gridEl.addEventListener('mouseup', () => { updateCombos(); onChange(); });
bpmSlider.addEventListener('change', onChange);
swingSlider.addEventListener('change', onChange);

// Named presets
function getPresets() {
  try { return JSON.parse(localStorage.getItem(STORAGE_KEY + ':presets') || '{}'); }
  catch { return {}; }
}

function savePresets(presets) {
  localStorage.setItem(STORAGE_KEY + ':presets', JSON.stringify(presets));
}

function refreshPresetList(selectName) {
  const presets = getPresets();
  presetSelect.innerHTML = '<option value="">-- unsaved --</option>';
  Object.keys(presets).sort().forEach(name => {
    const opt = document.createElement('option');
    opt.value = opt.textContent = name;
    presetSelect.appendChild(opt);
  });
  presetSelect.value = selectName !== undefined ? selectName : currentPreset;
}

function saveToPreset(name) {
  const presets = getPresets();
  presets[name] = getState();
  savePresets(presets);
  currentPreset = name;
  dirty = false;
  saveDot.classList.remove('dirty');
  refreshPresetList(name);
  cacheSession();
}

// Save: overwrite current preset, or prompt if none loaded
$('saveBtn').addEventListener('click', () => {
  if (currentPreset) {
    saveToPreset(currentPreset);
  } else {
    const name = prompt('Preset name:');
    if (!name || !name.trim()) return;
    saveToPreset(name.trim());
  }
});

// Save As: always prompt for a new name
$('saveAsBtn').addEventListener('click', () => {
  const name = prompt('Preset name:');
  if (!name || !name.trim()) return;
  saveToPreset(name.trim());
});

$('deletePresetBtn').addEventListener('click', () => {
  const name = presetSelect.value;
  if (!name) return;
  const presets = getPresets();
  delete presets[name];
  savePresets(presets);
  currentPreset = '';
  dirty = false;
  saveDot.classList.remove('dirty');
  refreshPresetList('');
  cacheSession();
});

presetSelect.addEventListener('change', () => {
  const name = presetSelect.value;
  if (!name) {
    currentPreset = '';
    dirty = false;
    saveDot.classList.remove('dirty');
    return;
  }
  const presets = getPresets();
  if (presets[name]) {
    currentPreset = name;
    dirty = false;
    saveDot.classList.remove('dirty');
    loadState(presets[name]);
    cacheSession();
  }
});

// Init
refreshPresetList();
rebuildUI();
try {
  const saved = JSON.parse(localStorage.getItem(STORAGE_KEY + ':session'));
  if (saved && saved.drums && saved.drums.length) {
    loadState(saved);
    currentPreset = saved._preset || '';
    dirty = false;
    saveDot.classList.remove('dirty');
    refreshPresetList(currentPreset);
  }
} catch {}
</script>
</body>
</html>
